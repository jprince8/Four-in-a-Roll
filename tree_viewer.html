<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Four-in-a-Roll Tree Viewer</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel-bg: #131b33;
      --card-bg: #1f2a44;
      --accent: #4c84ff;
      --text: #f5f8ff;
      --muted: #95a0c4;
      --border: #2d3a5c;
      --highlight: #f4d03f;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      min-height: 100vh;
    }
    #tree-container {
      flex: 3;
      overflow-y: auto;
      padding: 0 1.5rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      height: 100vh;
      position: relative;
    }
    .controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin: 0 -1.5rem 1rem;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 5;
      padding: 1rem 1.5rem;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
    }
    .controls button,
    .controls label {
      background: var(--panel-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.9rem;
      cursor: pointer;
      color: var(--text);
    }
    .controls button:hover,
    .controls label:hover {
      border-color: var(--accent);
      color: var(--highlight);
    }
    .controls input[type="file"] {
      display: none;
    }
    #layer-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      position: relative;
      padding-top: var(--dynamic-top-pad, 0px);
      padding-bottom: var(--dynamic-bottom-pad, 0px);
    }
    .layer {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      background: rgba(31, 42, 68, 0.6);
      border: 1px solid var(--border);
      --layer-highlight-color: var(--highlight);
      --layer-highlight-glow: rgba(244, 208, 63, 0.25);
      border-radius: 10px;
      padding: 1rem;
    }
    .layer.selected {
      border-color: var(--layer-highlight-color);
      box-shadow: 0 0 18px var(--layer-highlight-glow);
    }
    .layer.selected .layer-header {
      color: var(--layer-highlight-color);
    }
    .layer-header {
      font-weight: 600;
      color: var(--muted);
      letter-spacing: 0.02em;
    }
    .layer-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
    }
    body.single-row-mode .layer {
      overflow: hidden;
    }
    body.single-row-mode .layer-grid {
      flex-wrap: nowrap;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: thin;
      scroll-behavior: smooth;
      justify-content: flex-start;
      padding-bottom: 0.25rem;
      gap: 1.25rem;
    }
    body.single-row-mode .layer-grid::-webkit-scrollbar {
      height: 8px;
    }
    body.single-row-mode .layer-grid::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }
    body.single-row-mode .layer-grid::-webkit-scrollbar-thumb {
      background: rgba(148, 168, 216, 0.4);
      border-radius: 4px;
    }
    .node-card {
      --node-border-color: transparent;
      --node-border-width: 2px;
      --node-background-color: var(--card-bg);
      background: var(--node-background-color);
      border: var(--node-border-width) solid var(--node-border-color);
      border-radius: 12px;
      padding: 0.75rem;
      min-width: 220px;
      cursor: pointer;
      transition: border-color 0.2s ease, transform 0.2s ease;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      position: relative;
      z-index: 1;
    }
    .node-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    .node-card.selected {
      box-shadow: none;
    }
    .node-card.hidden {
      display: none;
    }
    .node-meta {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .board {
      display: grid;
      gap: 2px;
      background: #17203a;
      padding: 4px;
      border-radius: 8px;
      justify-content: center;
    }
    .cell {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.35);
      background: #1b2541;
    }
    .cell.p1 {
      background: #e63946;
    }
    .cell.p2 {
      background: #f4d03f;
    }
    #side-panel {
      flex: 1;
      background: var(--panel-bg);
      border-left: 1px solid var(--border);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-width: 420px;
      position: sticky;
      top: 0;
      height: 100vh;
      overflow-y: auto;
    }
    #stats h2 {
      margin: 0;
      font-size: 1.2rem;
    }
    #stats dl {
      margin: 0;
      display: grid;
      grid-template-columns: max-content 1fr;
      gap: 0.4rem 0.8rem;
      font-size: 0.95rem;
    }
    #stats dt {
      color: var(--muted);
    }
    #stats dd {
      margin: 0;
      font-weight: 600;
      color: var(--text);
    }
    pre {
      background: rgba(9, 13, 26, 0.7);
      padding: 0.75rem;
      border-radius: 8px;
      overflow: auto;
      max-height: 200px;
      font-size: 0.85rem;
      line-height: 1.3;
    }
    #status-bar {
      font-size: 0.9rem;
      color: var(--muted);
    }
    .edge-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 0;
    }
    .edge-overlay path {
      fill: none;
      opacity: 0.65;
    }
  </style>
</head>
<body>
  <main id="tree-container">
    <div class="controls">
      <button id="reload-default">Load Default JSON</button>
      <label for="json-file">Load JSON File<input id="json-file" type="file" accept="application/json"></label>
      <button id="clear-filter">Clear Filter</button>
      <button id="toggle-row-mode" aria-pressed="false">Single Row Mode: Off</button>
      <span id="status-bar">Ready</span>
    </div>
    <div id="layer-wrapper"></div>
  </main>
  <aside id="side-panel">
    <div id="stats">
      <h2>Node Details</h2>
      <p>Select a grid to inspect its data.</p>
    </div>
  </aside>

  <script>
    const DEFAULT_JSON_FALLBACK = 'outputs/state_graph_9.json';
    const PLAYER_NAMES = { 1: 'Red', 2: 'Yellow' };

    let state = {
      data: null,
      edges: [],
      turns: null,
      nodeElements: new Map(),
      layerElements: new Map(),
      nodesById: new Map(),
      parentsById: new Map(),
      childrenById: new Map(),
      currentSelected: null,
    };
    let delayedCenteringTimer = null;
    let singleRowModeEnabled = false;
    let pendingEdgeRedraw = null;

    function setStatus(message) {
      document.getElementById('status-bar').textContent = message;
    }

    function scheduleEdgeRedraw() {
      if (pendingEdgeRedraw !== null) return;
      pendingEdgeRedraw = requestAnimationFrame(() => {
        pendingEdgeRedraw = null;
        drawEdges();
      });
    }

    function applySingleRowMode() {
      const toggleButton = document.getElementById('toggle-row-mode');
      if (!toggleButton) return;
      if (singleRowModeEnabled) {
        document.body.classList.add('single-row-mode');
        toggleButton.textContent = 'Single Row Mode: On';
        toggleButton.setAttribute('aria-pressed', 'true');
      } else {
        document.body.classList.remove('single-row-mode');
        toggleButton.textContent = 'Single Row Mode: Off';
        toggleButton.setAttribute('aria-pressed', 'false');
      }
    }

    function resetDynamicPadding() {
      const wrapper = document.getElementById('layer-wrapper');
      if (!wrapper) return;
      wrapper.style.removeProperty('--dynamic-top-pad');
      wrapper.style.removeProperty('--dynamic-bottom-pad');
    }

    function resetState() {
      state = {
        data: null,
        edges: [],
        turns: null,
        nodeElements: new Map(),
        layerElements: new Map(),
        nodesById: new Map(),
        parentsById: new Map(),
        childrenById: new Map(),
        currentSelected: null,
      };
      resetDynamicPadding();
      document.getElementById('layer-wrapper').innerHTML = '';
      renderSummary();
    }

    async function loadJson(path) {
      try {
        setStatus(`Loading ${path} …`);
        resetState();
        const response = await fetch(`${path}?t=${Date.now()}`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status} ${response.statusText}`);
        }
        const json = await response.json();
        ingestData(json);
        renderTree();
        setStatus(`Loaded ${path}`);
      } catch (err) {
        console.error(err);
        setStatus(`Failed to load JSON: ${err.message}`);
      }
    }

    function handleLocalFile(file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const json = JSON.parse(event.target.result);
          resetState();
          ingestData(json);
          renderTree();
          setStatus(`Loaded local file: ${file.name}`);
        } catch (err) {
          console.error(err);
          setStatus(`Failed to parse JSON: ${err.message}`);
        }
      };
      reader.readAsText(file);
    }

    function normalizeNodeId(raw) {
      if (raw === null || raw === undefined) return null;
      if (typeof raw === 'number' && Number.isFinite(raw)) return raw;
      const num = Number(raw);
      if (!Number.isNaN(num)) return num;
      return String(raw);
    }

    function gatherParentIds(node) {
      const ids = new Set();
      if (!node) return ids;
      if (Array.isArray(node.parent_ids)) {
        node.parent_ids.forEach((value) => {
          const normalized = normalizeNodeId(value);
          if (normalized !== null) ids.add(normalized);
        });
      }
      if (node.parent_id !== null && node.parent_id !== undefined) {
        const normalized = normalizeNodeId(node.parent_id);
        if (normalized !== null) ids.add(normalized);
      }
      return ids;
    }

    function extractColumnsByParent(node) {
      const map = new Map();
      if (!node) return map;
      const appendColumns = (parentKey, values) => {
        const parentId = normalizeNodeId(parentKey);
        const safeValues = Array.isArray(values)
          ? values
              .map((value) => {
                const numeric = Number(value);
                return Number.isFinite(numeric) ? numeric : String(value);
              })
              .filter((value) => value !== null && value !== undefined)
          : [];
        if (!map.has(parentId)) {
          map.set(parentId, []);
        }
        if (safeValues.length) {
          map.get(parentId).push(...safeValues);
        }
      };

      const modern = node.columns_from_parents;
      if (modern && typeof modern === 'object' && !Array.isArray(modern)) {
        Object.entries(modern).forEach(([parentKey, values]) => appendColumns(parentKey, values));
      }

      const legacy = node.columns_from_parent;
      if (Array.isArray(legacy)) {
        appendColumns(node.parent_id ?? null, legacy);
      } else if (legacy && typeof legacy === 'object') {
        Object.entries(legacy).forEach(([parentKey, values]) => appendColumns(parentKey, values));
      }

      map.forEach((values, key) => {
        const seen = new Set();
        const filtered = values.filter((value) => {
          const dedupeKey = typeof value === 'number' ? value : String(value);
          if (seen.has(dedupeKey)) return false;
          seen.add(dedupeKey);
          return true;
        });
        filtered.sort((a, b) => {
          const numA = Number(a);
          const numB = Number(b);
          const aIsNum = Number.isFinite(numA);
          const bIsNum = Number.isFinite(numB);
          if (aIsNum && bIsNum) return numA - numB;
          if (aIsNum) return -1;
          if (bIsNum) return 1;
          return String(a).localeCompare(String(b));
        });
        map.set(key, filtered);
      });

      return map;
    }

    function sortParentIds(ids) {
      return ids.slice().sort((a, b) => {
        const numA = typeof a === 'number' ? a : Number(a);
        const numB = typeof b === 'number' ? b : Number(b);
        const aIsNum = Number.isFinite(numA);
        const bIsNum = Number.isFinite(numB);
        if (aIsNum && bIsNum) return numA - numB;
        if (aIsNum) return -1;
        if (bIsNum) return 1;
        return String(a).localeCompare(String(b));
      });
    }

    function describeParentId(id) {
      if (id === null || id === undefined) return 'unknown';
      if (id === 0) return 'root';
      return String(id);
    }

    function formatColumnsSummary(node) {
      const columnsByParent = extractColumnsByParent(node);
      if (!columnsByParent.size) return '—';
      const parts = [];
      sortParentIds(Array.from(columnsByParent.keys())).forEach((parentId) => {
        const columns = columnsByParent.get(parentId) || [];
        const label = describeParentId(parentId);
        const value = columns.length ? columns.join(', ') : '—';
        parts.push(`${label}: ${value}`);
      });
      return parts.join('<br>');
    }

    function ingestData(json) {
      state.data = json;
      state.edges = json.edges || [];
      state.turns = json.turns ?? null;
      json.nodes.forEach((node) => {
        state.nodesById.set(node.id, node);
        state.parentsById.set(node.id, gatherParentIds(node));
        state.childrenById.set(node.id, node.children_ids || []);
      });
      state.edges.forEach((edge) => {
        if (!state.parentsById.has(edge.to_id)) {
          state.parentsById.set(edge.to_id, new Set());
        }
        state.parentsById.get(edge.to_id).add(edge.from_id);
      });
    }

    function renderTree() {
      const wrapper = document.getElementById('layer-wrapper');
      wrapper.innerHTML = '';
      const layers = new Map();
      state.layerElements = new Map();
      state.data.nodes.forEach((node) => {
        if (!layers.has(node.layer)) layers.set(node.layer, []);
        layers.get(node.layer).push(node);
      });
      const orderedLayers = Array.from(layers.keys()).sort((a, b) => a - b);
      orderedLayers.forEach((layerNumber) => {
        const layerDiv = document.createElement('section');
        layerDiv.className = 'layer';
        state.layerElements.set(layerNumber, layerDiv);

        const layerNodes = layers.get(layerNumber).slice().sort((a, b) => a.id - b.id);

        const header = document.createElement('div');
        header.className = 'layer-header';
        header.textContent = turnHeader(layerNumber, layerNodes[0]);
        layerDiv.appendChild(header);

        const grid = document.createElement('div');
        grid.className = 'layer-grid';
        grid.addEventListener('scroll', scheduleEdgeRedraw);

        layerNodes.forEach((node) => {
          const card = document.createElement('article');
          card.className = 'node-card';
          card.dataset.nodeId = node.id;
          const defaultBorder = '#aab4ce';
          const borderColor = node.border_color || null;
          const normalized = borderColor ? borderColor.toLowerCase() : null;
          const isCustomBorder = normalized && normalized !== defaultBorder;
          const borderWidth = isCustomBorder ? '6px' : '2px';
          const appliedColor = borderColor || '#2d3a5c';

          card.style.setProperty('--node-border-color', appliedColor);
          card.style.setProperty('--node-border-width', borderWidth);
          card.style.setProperty('--node-background-color', node.background_color || '#1f2a44');

          const meta = document.createElement('div');
          meta.className = 'node-meta';
          const statusText = describeStatus(node.status);
          const statusDisplay = statusText || '&nbsp;';
          meta.innerHTML = `<span>#${node.id}</span><span>${statusDisplay}</span>`;
          card.appendChild(meta);

          card.appendChild(renderBoard(node.board));

          const extra = document.createElement('div');
          extra.className = 'node-meta';
          const futureWins = formatWinnerList(node.downstream_winners);
          extra.innerHTML = `<span>Children: ${node.children_ids.length}</span><span>Future Wins: ${futureWins}</span>`;
          card.appendChild(extra);

          card.addEventListener('click', (event) => {
            event.stopPropagation();
            selectNode(node.id);
          });

          state.nodeElements.set(node.id, card);
          grid.appendChild(card);
        });

        layerDiv.appendChild(grid);
        wrapper.appendChild(layerDiv);
      });
      scheduleEdgeRedraw();
      if (state.currentSelected == null) {
        renderSummary();
      }
    }

    function renderBoard(board) {
      const rows = board.length;
      const cols = board[0].length;
      const boardDiv = document.createElement('div');
      boardDiv.className = 'board';
      boardDiv.style.gridTemplateColumns = `repeat(${cols}, 22px)`;
      boardDiv.style.gridTemplateRows = `repeat(${rows}, 22px)`;

      for (let r = rows - 1; r >= 0; r -= 1) {
        for (let c = 0; c < cols; c += 1) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (board[r][c] === 1) cell.classList.add('p1');
          if (board[r][c] === 2) cell.classList.add('p2');
          boardDiv.appendChild(cell);
        }
      }

      return boardDiv;
    }

    function selectNode(id) {
      if (delayedCenteringTimer) {
        clearTimeout(delayedCenteringTimer);
        delayedCenteringTimer = null;
      }
      const selectedCard = state.nodeElements.get(id);
      if (state.currentSelected === id) {
        if (selectedCard) {
          scheduleCardCentering(selectedCard);
        }
        return;
      }
      resetDynamicPadding();
      state.currentSelected = id;
      state.nodeElements.forEach((card, nodeId) => {
        card.classList.toggle('selected', nodeId === id);
      });
      updateSelectedLayer(id);
      applyFilter(id);
      updateStats(id);
      if (selectedCard) {
        scheduleCardCentering(selectedCard);
      }
    }

    function scheduleCardCentering(card, attempt = 0) {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => centerCardInContainer(card, attempt));
      });
    }

    function centerCardInContainer(card, attempt = 0) {
      const container = document.getElementById('tree-container');
      if (!container) {
        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        return;
      }
      const controls = container.querySelector('.controls');
      const controlsHeight = controls ? controls.offsetHeight : 0;
      const wrapper = document.getElementById('layer-wrapper');
      const containerRect = container.getBoundingClientRect();
      const cardRect = card.getBoundingClientRect();
      const offsetWithinContainer = cardRect.top - containerRect.top - controlsHeight;
      const availableHeight = container.clientHeight - controlsHeight;
      const targetScroll = container.scrollTop + offsetWithinContainer - (availableHeight / 2 - cardRect.height / 2);
      const maxScroll = container.scrollHeight - container.clientHeight;
      const maxAttempts = 4;
      if (wrapper && attempt < maxAttempts) {
        if (targetScroll < 0) {
          const needed = Math.ceil(-targetScroll);
          const current = parseFloat(wrapper.style.getPropertyValue('--dynamic-top-pad')) || 0;
          if (needed > current) {
            wrapper.style.setProperty('--dynamic-top-pad', `${needed}px`);
            scheduleCardCentering(card, attempt + 1);
            return;
          }
        } else if (targetScroll > maxScroll) {
          const needed = Math.ceil(targetScroll - maxScroll);
          const current = parseFloat(wrapper.style.getPropertyValue('--dynamic-bottom-pad')) || 0;
          if (needed > current) {
            wrapper.style.setProperty('--dynamic-bottom-pad', `${needed}px`);
            scheduleCardCentering(card, attempt + 1);
            return;
          }
        }
      }
      const clamped = Math.min(Math.max(targetScroll, 0), container.scrollHeight - container.clientHeight);
      container.scrollTo({ top: clamped, behavior: 'smooth' });
    }

    function applyFilter(id) {
      const allowed = new Set([id]);
      const ancestorQueue = [id];
      while (ancestorQueue.length) {
        const current = ancestorQueue.shift();
        const parents = state.parentsById.get(current);
        if (!parents) continue;
        parents.forEach((parentId) => {
          if (parentId == null) return;
          if (!allowed.has(parentId)) {
            allowed.add(parentId);
            if (state.nodeElements.has(parentId)) {
              ancestorQueue.push(parentId);
            }
          }
        });
      }
      const queue = [id];
      while (queue.length) {
        const current = queue.shift();
        const children = state.childrenById.get(current) || [];
        children.forEach((childId) => {
          if (!allowed.has(childId)) {
            allowed.add(childId);
            queue.push(childId);
          }
        });
      }
      state.nodeElements.forEach((card, nodeId) => {
        card.classList.toggle('hidden', !allowed.has(nodeId));
      });
      scheduleEdgeRedraw();
    }

    function clearFilter() {
      state.currentSelected = null;
      resetDynamicPadding();
      state.nodeElements.forEach((card) => {
        card.classList.remove('hidden', 'selected');
      });
      state.layerElements.forEach((layer) => {
        layer.classList.remove('selected');
        layer.style.removeProperty('--layer-highlight-color');
        layer.style.removeProperty('--layer-highlight-glow');
      });
      renderSummary();
      scheduleEdgeRedraw();
    }

    function updateSelectedLayer(nodeId) {
      const node = state.nodesById.get(nodeId);
      const layerNumber = node ? node.layer : null;
      const highlight = { color: '#4c84ff', glow: 'rgba(76, 132, 255, 0.35)' };
      state.layerElements.forEach((layerEl, key) => {
        const isSelected = key === layerNumber;
        layerEl.classList.toggle('selected', isSelected);
        if (isSelected) {
          layerEl.style.setProperty('--layer-highlight-color', highlight.color);
          layerEl.style.setProperty('--layer-highlight-glow', highlight.glow);
        } else {
          layerEl.style.removeProperty('--layer-highlight-color');
          layerEl.style.removeProperty('--layer-highlight-glow');
        }
      });
    }

    function updateStats(id) {
      const node = state.nodesById.get(id);
      if (!node) return;
      const statsDiv = document.getElementById('stats');
      const prunedBelow = node.has_orange_below ? 'Yes' : 'No';
      const parents = state.parentsById.get(id) || new Set();
      const parentList = Array.from(parents).filter((value) => value !== null && value !== undefined);
      const childrenIds = Array.isArray(node.children_ids) ? node.children_ids : [];
      const drawnChildrenIds = Array.isArray(node.drawn_children_ids) ? node.drawn_children_ids : [];
      const sortedParents = sortParentIds(parentList);
      const parentLabel = sortedParents.length
        ? sortedParents.map((parentId) => describeParentId(parentId)).join(', ')
        : 'root';
      const statusLabel = describeStatus(node.status) || '—';
      const columnsSummary = formatColumnsSummary(node);
      const parentTitle = sortedParents.length > 1 ? 'Parents' : 'Parent';
      statsDiv.innerHTML = `
        <h2>Node #${node.id}</h2>
        <dl>
          <dt>Turn</dt><dd>${node.layer}</dd>
          <dt>Status</dt><dd>${statusLabel}</dd>
          <dt>Entered By</dt><dd>${playerName(node.entered_by_player)}</dd>
          <dt>Future Wins</dt><dd>${formatWinnerList(node.downstream_winners)}</dd>
          <dt>Columns From Parents</dt><dd>${columnsSummary}</dd>
          <dt>Total Children</dt><dd>${childrenIds.length}</dd>
          <dt>Drawn Children</dt><dd>${drawnChildrenIds.length}</dd>
          <dt>${parentTitle}</dt><dd>${parentLabel}</dd>
          <dt>Pruned No-win Subtree Below</dt><dd>${prunedBelow}</dd>
        </dl>
      `;
    }

    function drawEdges() {
      if (!state.data) return;
      const wrapper = document.getElementById('layer-wrapper');
      if (!wrapper) return;
      let overlay = document.getElementById('edge-overlay');
      if (!overlay) {
        overlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        overlay.setAttribute('id', 'edge-overlay');
        overlay.classList.add('edge-overlay');
        wrapper.appendChild(overlay);
      }
      while (overlay.firstChild) overlay.removeChild(overlay.firstChild);

      const width = wrapper.scrollWidth;
      const height = wrapper.scrollHeight;
      overlay.setAttribute('width', width);
      overlay.setAttribute('height', height);
      overlay.setAttribute('viewBox', `0 0 ${width} ${height}`);
      overlay.style.width = `${width}px`;
      overlay.style.height = `${height}px`;

      const wrapperRect = wrapper.getBoundingClientRect();
      state.edges.forEach((edge) => {
        const parentEl = state.nodeElements.get(edge.from_id);
        const childEl = state.nodeElements.get(edge.to_id);
        if (!parentEl || !childEl) return;
        if (parentEl.classList.contains('hidden') || childEl.classList.contains('hidden')) return;

        const parentRect = parentEl.getBoundingClientRect();
        const childRect = childEl.getBoundingClientRect();
        const x1 = parentRect.left - wrapperRect.left + parentRect.width / 2;
        const y1 = parentRect.bottom - wrapperRect.top;
        const x2 = childRect.left - wrapperRect.left + childRect.width / 2;
        const y2 = childRect.top - wrapperRect.top;
        const midY = (y1 + y2) / 2;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', `M ${x1} ${y1} C ${x1} ${midY} ${x2} ${midY} ${x2} ${y2}`);
        path.setAttribute('stroke', edge.mover === 1 ? '#e63946' : '#f4d03f');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        overlay.appendChild(path);
      });
    }

    function turnHeader(layerNumber, sampleNode) {
      if (layerNumber === 0) return 'Turn 0 - Start';
      return `Turn ${layerNumber}`;
    }

    function classifyStatus(status) {
      if (!status) return 'other';
      if (/terminal win for Player 1/i.test(status)) return 'terminal_red';
      if (/terminal win for Player 2/i.test(status)) return 'terminal_yellow';
      if (/forced path leading to Player 1 victory/i.test(status)) return 'forced_red';
      if (/forced path leading to Player 2 victory/i.test(status)) return 'forced_yellow';
      if (/trimmed alternative branch/i.test(status)) return 'pruned';
      if (/dead end after pruning/i.test(status)) return 'dead_end';
      if (/ongoing position/i.test(status)) return 'ongoing';
      return 'other';
    }

    function describeStatus(status) {
      const key = classifyStatus(status);
      const turns = state.turns ?? '?';
      switch (key) {
        case 'ongoing':
          return '';
        case 'forced_red':
          return 'Red will win';
        case 'forced_yellow':
          return 'Yellow will win';
        case 'terminal_red':
          return 'Red win';
        case 'terminal_yellow':
          return 'Yellow win';
        case 'pruned':
          return `no wins within ${turns} turns`;
        case 'dead_end':
          return `Dead end (pruned within ${turns} turns)`;
        default:
          return (status || '').replace(/Player 1/g, 'Red').replace(/Player 2/g, 'Yellow');
      }
    }

    function playerName(playerId) {
      return PLAYER_NAMES[playerId] || (playerId == null ? '—' : playerId);
    }

    function formatWinnerList(list) {
      if (!list || list.length === 0) return '—';
      const hasRed = list.includes(1);
      const hasYellow = list.includes(2);
      if (hasRed && hasYellow) return 'Both';
      if (hasRed) return 'Red';
      if (hasYellow) return 'Yellow';
      return list.join(', ');
    }

    function renderSummary() {
      const statsDiv = document.getElementById('stats');
      if (!statsDiv) return;
      if (!state.data) {
        statsDiv.innerHTML = '<h2>Tree Stats</h2><p>Load a JSON file to explore the tree.</p>';
        return;
      }
      const nodes = state.data.nodes || [];
      const counts = {
        terminal_red: 0,
        terminal_yellow: 0,
        forced_red: 0,
        forced_yellow: 0,
        pruned: 0,
        dead_end: 0,
        ongoing: 0,
        other: 0,
      };
      nodes.forEach((node) => {
        const key = classifyStatus(node.status);
        if (counts[key] !== undefined) {
          counts[key] += 1;
        } else {
          counts.other += 1;
        }
      });
      const total = nodes.length;
      const activeRaw = total
        - counts.pruned
        - counts.dead_end
        - counts.terminal_red
        - counts.terminal_yellow
        - counts.forced_red
        - counts.forced_yellow;
      const active = activeRaw < 0 ? 0 : activeRaw;
      const prunedLabel = state.turns != null ? `No wins within ${state.turns} turns` : 'No wins within set depth';
      statsDiv.innerHTML = `
        <h2>Tree Stats</h2>
        <dl>
          <dt>Turns</dt><dd>${state.turns ?? '—'}</dd>
          <dt>Total Grids</dt><dd>${total}</dd>
          <dt>Red win</dt><dd>${counts.terminal_red}</dd>
          <dt>Yellow win</dt><dd>${counts.terminal_yellow}</dd>
          <dt>Red will win</dt><dd>${counts.forced_red}</dd>
          <dt>Yellow will win</dt><dd>${counts.forced_yellow}</dd>
          <dt>${prunedLabel}</dt><dd>${counts.pruned}</dd>
          <dt>Dead-end after pruning</dt><dd>${counts.dead_end}</dd>
          <dt>Still undecided positions</dt><dd>${active}</dd>
        </dl>
      `;
    }

    let resolvedDefaultJson = DEFAULT_JSON_FALLBACK;

    async function resolveDefaultJson() {
      try {
        const response = await fetch(`outputs/latest.json?t=${Date.now()}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const payload = await response.json();
        if (payload && typeof payload.path === 'string' && payload.path.endsWith('.json')) {
          resolvedDefaultJson = payload.path;
        }
      } catch (err) {
        console.warn('Falling back to default JSON due to:', err);
        resolvedDefaultJson = DEFAULT_JSON_FALLBACK;
      }
      return resolvedDefaultJson;
    }

    document.getElementById('reload-default').addEventListener('click', () => loadJson(resolvedDefaultJson));
    document.getElementById('clear-filter').addEventListener('click', clearFilter);
    document.getElementById('toggle-row-mode').addEventListener('click', () => {
      singleRowModeEnabled = !singleRowModeEnabled;
      applySingleRowMode();
      scheduleEdgeRedraw();
    });
    const jsonFileInput = document.getElementById('json-file');
    jsonFileInput.setAttribute('nwworkingdir', 'outputs');
    jsonFileInput.setAttribute('data-preferred-dir', 'outputs');
    jsonFileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) handleLocalFile(file);
      event.target.value = '';
    });
    document.body.addEventListener('click', (event) => {
      if (event.target === document.body || event.target.id === 'tree-container') {
        clearFilter();
      }
    });
    window.addEventListener('resize', scheduleEdgeRedraw);

    (async () => {
      const path = await resolveDefaultJson();
      loadJson(path);
      applySingleRowMode();
      scheduleEdgeRedraw();
    })();
  </script>
</body>
</html>
